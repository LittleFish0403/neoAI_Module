# ä¸‰è§’å½¢(Triangles)
## ä¸‰è§’å½¢åæ ‡(Triangle Coordinates)
ä¸‰è§’å½¢å†…çš„åŒºåŸŸå¯ä»¥ç”¨ä¸‰ä¸ªéžå…±çº¿çš„ç‚¹$A$,$B$,$C$å®šä¹‰,å¹¶å¯ä»¥ç”¨ä»£æ•°å½¢å¼å†™ä¸ºä¸‰ä¸ªç‚¹çš„**å‡¸ç»„åˆ**:
$$
P(w,u,v)=wA+uB+vC\\s.t.\quad0\le w,u,v\\1=w+u+v
$$
æˆ–è€…ç­‰ä»·äºŽ
$$
P(u,v)=(1-u-v)A+uB+vC\\\ =A+u(B-A)+v(C-A)\\s.t.\quad0\le u,v\\u+v\le 1
$$

è¿™é‡Œ$u$,$v$è¢«ç§°ä¸º"é‡å¿ƒåæ ‡".
å¦‚æžœæˆ‘ä»¬åˆ é™¤$u$å’Œ$v$çš„èŒƒå›´,æˆ‘ä»¬å°±å¾—åˆ°äº†ä¸‰è§’å½¢æ‰€åœ¨å¹³é¢çš„è¡¨è¾¾å¼.ç”¨ä¸‹é¢çš„å°éƒ¨ä»¶æ¥äº†è§£$u$å’Œ$v$çš„è¡Œä¸º.
```python
one_triangle = t.tensor([[0, 0, 0], [3, 0.5, 0], [2, 3, 0]])
A, B, C = one_triangle
x, y, z = one_triangle.T

fig = setup_widget_fig_triangle(x, y, z)

@interact(u=(-0.5, 1.5, 0.01), v=(-0.5, 1.5, 0.01))
def response(u=0.0, v=0.0):
    P = A + u * (B - A) + v * (C - A)
    fig.data[2].update({"x": [P[0]], "y": [P[1]]})

display(fig)
```

### ä¸‰è§’-å°„çº¿ç›¸äº¤
ç»™å®šä¸€æ¡å°„çº¿çš„åŽŸç‚¹$O$å’Œæ–¹å‘$D$,æˆ‘ä»¬çš„ç›¸äº¤ç®—æ³•å°†åŒ…å«ä»¥ä¸‹ä¸¤ä¸ªæ­¥éª¤:
- é€šè¿‡è”ç«‹æ–¹ç¨‹$P(u,v)=P(s)$æ¥è®¡ç®—äº¤ç‚¹åæ ‡.
- æ£€æŸ¥$u$å’Œ$v$æ˜¯å¦æ»¡è¶³èŒƒå›´.

å±•å¼€ç­‰å¼$P(u,v)=P(s)$,æˆ‘ä»¬æœ‰:
$$
A+u(B-A)+v(C-A)=O+sD\\
\Rightarrow\begin{pmatrix}-D&(B-A)&(C-A)\end{pmatrix}\begin{pmatrix}s\\u\\v\end{pmatrix}=(O-A)\\
\Rightarrow\begin{pmatrix}-D_x&(B-A)_x&(C-A)_x\\-D_y&(B-A)_y&(C-A)_z\\-D_z&(B-A)_z&(C-A)_z\end{pmatrix}\begin{pmatrix}s\\u\\v\end{pmatrix}=\begin{pmatrix}(O-A)_x\\(O-A)_y\\(O-A)_z\end{pmatrix}
$$
å› æ­¤æˆ‘ä»¬å¯ä»¥é€šè¿‡æ±‚è§£è¿™ä¸ªçº¿æ€§æ–¹ç¨‹è§£å‡ºäº¤ç‚¹çš„åæ ‡`s`,`u`å’Œ`v`.

### Exercise-å®Œæˆ`triangle_ray_intersects`
::: tip TIPS
Difficulty: ðŸ”´ðŸ”´ðŸ”´âšªâšª

Importance: ðŸ”µðŸ”µðŸ”µâšªâšª

ä½ åº”è¯¥èŠ±æœ€å¤š15-20åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.

:::

ä½¿ç”¨`torch.linalg.solve`å’Œ`torch.stack`,å®Œæˆ`triangle_ray_intersects(A, B, C, O, D)`

ä¸€äº›æç¤º:
- å¦‚æžœä½ æœ‰ä¸€ä¸ªé›¶ç»´çš„å¼ é‡,å½¢çŠ¶ä¸º`()`,åªå‚¨å­˜äº†å•ä¸ªå€¼,è¯·ä½¿ç”¨`.item()`æ–¹æ³•æŠŠä»–è½¬æ¢ä¸ºæ™®é€šçš„Pythonå€¼.
- å¦‚æžœä½ æœ‰ä¸€ä¸ªå½¢çŠ¶ä¸º`tensor.shape = (3, ...)`çš„å¼ é‡,é‚£ä¹ˆä½ å¯ä»¥ç”¨ç±»ä¼¼`s, u, v = tensor`çš„æ–¹æ³•æ²¿ç€ç¬¬ä¸€ä¸ªç»´åº¦æŠŠè¿™ä¸ªå¼ é‡åˆ†è§£æˆä¸‰ä¸ªç‹¬ç«‹çš„å¼ é‡,å°±å’Œä½ åˆ†è§£pythonä¸­çš„åˆ—è¡¨ä¸€æ ·.
    - æ³¨æ„,å¦‚æžœä½ æƒ³è¦åˆ†è§£çš„ç»´åº¦ä¸åœ¨ç¬¬ä¸€ä¸ªç»´åº¦,æœ‰ä¸€ä¸ªå¾ˆå¥½çš„æ›¿æ¢æ–¹æ³•æ˜¯`s, u, v = tensor.unbind(dim)`,å…¶ä¸­`dim`æŒ‡å®šäº†ä½ æƒ³è¦æ‹†åˆ†çš„ç»´åº¦.
- å¦‚æžœä½ å‡½æ•°æ²¡æ­£å¸¸å·¥ä½œ,å°è¯•ç”¨æ¼‚äº®çš„æ•´æ•°åˆ¶ä½œä¸€ä¸ªç®€å•çš„å°„çº¿å’Œä¸‰è§’å½¢,æ‰‹åŠ¨è®¡ç®—æ˜¯å¦ç›¸äº¤,ç„¶åŽä»Žè¿™å¼€å§‹æ…¢æ…¢è°ƒè¯•.

```python
Point = Float[Tensor, "points=3"]

@jaxtyped
@typeguard.typechecked
def triangle_ray_intersects(A: Point, B: Point, C: Point, O: Point, D: Point) -> bool:
    '''
    A: shape (3,), one vertex of the triangle
    B: shape (3,), second vertex of the triangle
    C: shape (3,), third vertex of the triangle
    O: shape (3,), origin point
    D: shape (3,), direction point

    Return True if the ray and the triangle intersect.
    '''
    pass


tests.test_triangle_ray_intersects(triangle_ray_intersects)
```

::: details SOLUTION
```python 
def triangle_ray_intersects(A: Point, B: Point, C: Point, O: Point, D: Point) -> bool:
    '''
    A: shape (3,), one vertex of the triangle
    B: shape (3,), second vertex of the triangle
    C: shape (3,), third vertex of the triangle
    O: shape (3,), origin point
    D: shape (3,), direction point

    Return True if the ray and the triangle intersect.
    '''
    # SOLUTION
    s, u, v = t.linalg.solve(
        t.stack([-D, B - A, C - A], dim=1), 
        O - A
    )
    return ((u >= 0) & (v >= 0) & (u + v <= 1)).item()
```
:::

## æ¸²æŸ“å•ä¸ªä¸‰è§’å½¢(Single-Triangle Rendering)
åœ¨ä»…è°ƒç”¨`torch.linagl.solve`çš„å‰æä¸‹å®Œæˆ`raytrace_triangle`.

é‡å¡‘è¾“å‡ºå¼ é‡å¹¶ä½¿ç”¨`plt.imshow`è¿›è¡Œå¯è§†åŒ–.è¾¹ç¼˜åƒç´ åŒ–å’Œé”¯é½¿çŠ¶æ˜¯æ­£å¸¸çš„ - ä½¿ç”¨å°‘é‡åƒç´ æ˜¯å¿«é€Ÿè°ƒè¯•çš„å¥½æ–¹æ³•.

å¦‚æžœä½ è§‰å¾—ä½ çš„ä»£ç å·²ç»èƒ½æ­£å¸¸è·‘äº†,è¯·å¢žåŠ åƒç´ çš„æ•°é‡éªŒè¯æ›´é«˜åˆ†è¾¨çŽ‡ä¸‹è¾¹ç¼˜åƒç´ åŒ–ç¨‹åº¦æ˜¯å¦é™ä½Ž.

### è§†å›¾å’Œå‰¯æœ¬(Views and Copies)
çŸ¥é“ä½ ä»€ä¹ˆæ—¶å€™åˆ›å»ºäº†`Tensor`çš„å‰¯æœ¬è€Œä¸æ˜¯åˆ›å»ºäº†ä¸ŽåŽŸå§‹å¼ é‡å…±äº«æ•°æ®çš„è§†å›¾æ˜¯å¾ˆé‡è¦çš„.å°½å¯èƒ½ä½¿ç”¨è§†å›¾æ˜¯æœ€å¥½çš„,å¯ä»¥é¿å…ä¸å¿…è¦çš„å†…å­˜ç©ºé—´å ç”¨.ä½†æ˜¯å¦ä¸€æ–¹é¢,ä¿®æ”¹è§†å›¾ä¼šä¿®æ”¹åŽŸå§‹å¼ é‡,æœ‰æ—¶å€™å¯èƒ½ä¼šé€ æˆä¸€äº›å¥‡æ€ªçš„ç»“æžœ.å¦‚æžœä½ ä¸ç¡®å®šå‡½æ•°æ˜¯å¦è¿”å›žè§†å›¾,è¯·å‚é˜…[æ–‡æ¡£](https://pytorch.org/docs/stable/tensor_view.html).å¸¸ç”¨å‡½æ•°è¿”å›žæƒ…å†µé€ŸæŸ¥:
- `torch.expand`: æ€»æ˜¯è¿”å›žè§†å›¾
- `torch.view`: æ€»æ˜¯è¿”å›žè§†å›¾
- `torch.detach`: æ€»æ˜¯è¿”å›žè§†å›¾
- `torch.repeat`: æ€»æ˜¯å¤åˆ¶
- `torch.clone`: æ€»æ˜¯å¤åˆ¶
- `torch.flip`: æ€»æ˜¯å¤åˆ¶(å’Œ`numpy.flip`ä¸åŒ,åŽè€…æ€»æ˜¯è¿”å›žè§†å›¾)
- `torch.tensor`: æ€»æ˜¯å¤åˆ¶,ä½†æ˜¯PyTorchæŽ¨èä½¿ç”¨`.clone().detach()`æ›¿æ¢è¯¥å‡½æ•°
- `torch.Tensor.contiguous`: å¦‚æžœå¯ä»¥å°±è¿”å›žè‡ªèº«,å¦åˆ™å°±è¿”å›žå‰¯æœ¬
- `torch.transpose`: å¦‚æžœå¯ä»¥å°±è¿”å›žè§†å›¾,å¦åˆ™å°±è¿”å›žå‰¯æœ¬
- `torch.reshape`: å¦‚æžœå¯ä»¥å°±è¿”å›žè§†å›¾,å¦åˆ™å°±è¿”å›žå‰¯æœ¬
- `torch.flatten`: å¦‚æžœå¯ä»¥å°±è¿”å›žè§†å›¾,å¦åˆ™å°±è¿”å›žå‰¯æœ¬(å’Œ`numpy.flatten`ä¸åŒ,åŽè€…æ€»æ˜¯è¿”å›žå‰¯æœ¬)
- `einops.repeat`: å¦‚æžœå¯ä»¥å°±è¿”å›žè§†å›¾,å¦åˆ™å°±è¿”å›žå‰¯æœ¬
- `einops.rearrange`: å¦‚æžœå¯ä»¥å°±è¿”å›žè§†å›¾,å¦åˆ™å°±è¿”å›žå‰¯æœ¬
- åŸºç¡€ç´¢å¼•ä¼šè¿”å›žè§†å›¾,é«˜çº§ç´¢å¼•ä¼šè¿”å›žå‰¯æœ¬.

### å­˜å‚¨å¯¹è±¡
åœ¨ä¸€ä¸ª`Tensor`ä¸Šè°ƒç”¨`storage()`ä¼šè¿”å›žä¸€ä¸ªåŒ…è£…äº†åº•å±‚C++æ•°ç»„çš„Pythonå¯¹è±¡.æ— è®º`Tensor`çš„ç»´æ•°æ˜¯å¤šå°‘,è¿™éƒ½æ˜¯ä¸ªä¸€ç»´æ•°ç»„.è¿™èƒ½è®©ä½ çœ‹åˆ°`Tensor`æŠ½è±¡å‰çš„å†…å®¹å¹¶äº†è§£åˆ°å®žé™…æ•°æ®åœ¨å†…å­˜ä¸­çš„æŽ’å¸ƒæ–¹å¼.

è¯·æ³¨æ„æ¯æ¬¡è°ƒç”¨`storage()`éƒ½ä¼šç”Ÿæˆä¸€ä¸ªæ–°çš„pythonåŒ…è£…å¯¹è±¡,å¹¶ä¸”`x.storage() == x.storage()`å’Œ`x.storage() is x.storage()`ç»“æžœå‡ä¸ºFalse.

å¦‚æžœéœ€è¦æ£€æŸ¥ä¸¤ä¸ª`Tensor`æ˜¯å¦å…±äº«åº•å±‚çš„C++æ•°ç»„,å¯ä»¥æ¯”è¾ƒä»–ä»¬çš„`storage().data_ptr()`å­—æ®µ,è¿™æ˜¯ä»–ä»¬åº•å±‚C++æ•°ç»„åœ¨å†…å­˜ä¸­çš„æŒ‡é’ˆ.è¿™å¯¹äºŽè°ƒè¯•å¾ˆæœ‰ç”¨.

### `Tensor._base`
å¦‚æžœ`x`æ˜¯ä¸€ä¸ªè§†å›¾,ä½ å¯ä»¥ç”¨`x._base`è®¿é—®ä»–çš„åŽŸå§‹`Tensor`.è¿™æ˜¯ä¸€ä¸ªæ²¡æœ‰å†™åœ¨æ–‡æ¡£é‡Œçš„å†…éƒ¨åŠŸèƒ½,äº†è§£ä¸€ä¸‹å¾ˆæœ‰ç”¨.è€ƒè™‘ä¸‹é¢è¿™æ®µä»£ç :
```python
x = t.zeros(1024*1024*1024)
y = x[0]
del x
```

è¿™é‡Œ,`y`æ˜¯é€šè¿‡åŸºç¡€ç´¢å¼•åˆ›å»ºçš„,æ‰€ä»¥`y`æ˜¯ä¸€ä¸ªè§†å›¾ä¸”`y._base`æŒ‡å‘`x`.è¿™æ„å‘³ç€æ‰§è¡Œ`del x`åŽç³»ç»Ÿä¸ä¼šé‡Šæ”¾4GBå†…å­˜,è¯¥ç©ºé—´ä»ç„¶ä¼šè¢«ç»§ç»­ä½¿ç”¨,è¿™ä¸ªç»“æžœå¯èƒ½ä¼šéžå¸¸åç›´è§‰.ä½ å¯ä»¥ç”¨`y = x[0].clone()`è¿›è¡Œæ›¿æ¢,ä½¿ç”¨è¿™ä¸ªæ–¹æ³•åŽå…è®¸ä½ å›žæ”¶`x`çš„å†…å­˜.

### Exercise-å®Œæˆ`raytrace_triangle`
::: tip TIPS
Difficulty: ðŸ”´ðŸ”´ðŸ”´ðŸ”´âšª

Importance: ðŸ”µðŸ”µðŸ”µðŸ”µâšª

ä½ åº”è¯¥èŠ±æœ€å¤š15-20åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.

è¿™ä¸ªç»ƒä¹ å’Œ`intersect_rays_1d`éš¾åº¦å·®ä¸å¤š,ä½†æˆ‘è¿˜æ˜¯å¸Œæœ›ä½ èƒ½å®Œæˆçš„æ›´ç†Ÿç»ƒ.
:::

ä½ éœ€è¦å®Œæˆå‡½æ•°`raytrace_triangle`,åŠŸèƒ½æ˜¯èƒ½æ£€æµ‹`ray`ä¸­çš„æ¯æ¡å°„çº¿æ˜¯å¦å’Œä¸€ä¸ªç»™å®šçš„ä¸‰è§’å½¢ç›¸äº¤.
```python
def raytrace_triangle(
    rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
    triangle: Float[Tensor, "trianglePoints=3 dims=3"]
) -> Bool[Tensor, "nrays"]:
    '''
    For each ray, return True if the triangle intersects that ray.
    '''
    pass


A = t.tensor([1, 0.0, -0.5])
B = t.tensor([1, -0.5, 0.0])
C = t.tensor([1, 0.5, 0.5])
num_pixels_y = num_pixels_z = 15
y_limit = z_limit = 0.5

# Plot triangle & rays
test_triangle = t.stack([A, B, C], dim=0)
rays2d = make_rays_2d(num_pixels_y, num_pixels_z, y_limit, z_limit)
triangle_lines = t.stack([A, B, C, A, B, C], dim=0).reshape(-1, 2, 3)
render_lines_with_plotly(rays2d, triangle_lines)

# Calculate and display intersections
intersects = raytrace_triangle(rays2d, test_triangle)
img = intersects.reshape(num_pixels_y, num_pixels_z).int()
imshow(img, origin="lower", width=600, title="Triangle (as intersected by rays)")
```

::: details SOLUTION
```python 
def raytrace_triangle(
    rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
    triangle: Float[Tensor, "trianglePoints=3 dims=3"]
) -> Bool[Tensor, "nrays"]:
    '''
    For each ray, return True if the triangle intersects that ray.
    '''
    # SOLUTION
    NR = rays.size(0)

    # Triangle is [[Ax, Ay, Az], [Bx, By, Bz], [Cx, Cy, Cz]]
    A, B, C = einops.repeat(triangle, "pts dims -> pts NR dims", NR=NR)
    assert A.shape == (NR, 3)

    # Each element of `rays` is [[Ox, Oy, Oz], [Dx, Dy, Dz]]
    O, D = rays.unbind(dim=1)
    assert O.shape == (NR, 3)

    # Define matrix on left hand side of equation
    mat: Float[Tensor, "NR 3 3"] = t.stack([- D, B - A, C - A], dim=-1)

    # Get boolean of where matrix is singular, and replace it with the identity in these positions
    # Note - this works because mat[is_singular] has shape (NR_where_singular, 3, 3), so we
    # can broadcast the identity matrix to that shape.
    dets: Float[Tensor, "NR"] = t.linalg.det(mat)
    is_singular = dets.abs() < 1e-8
    mat[is_singular] = t.eye(3)

    # Define vector on the right hand side of equation
    vec = O - A

    # Solve eqns
    sol: Float[Tensor, "NR 3"] = t.linalg.solve(mat, vec)
    s, u, v = sol.unbind(dim=-1)

    # Return boolean of (matrix is nonsingular, and solution is in correct range implying intersection)
    return ((u >= 0) & (v >= 0) & (u + v <= 1) & ~is_singular)
```
:::

## è°ƒè¯•(Debugging)
è°ƒè¯•ä»£ç æ˜¯ä¸€ä»¶éžå¸¸é‡è¦çš„äº‹.å°±åƒç”¨GPTè¾…åŠ©ä»£ç ä¸€æ ·,ä»–å¯ä»¥æ˜¾è‘—åŠ å¿«ä½ çš„å¼€å‘é€Ÿåº¦,è®©ä½ ä¸å†bugä¸Šæµªè´¹è¿‡å¤šçš„æ—¶é—´.

ä¸ºäº†è®©ä½ ç»ƒä¹ ä½¿ç”¨VSCodeçš„å†…ç½®è°ƒè¯•å™¨è¿›è¡Œè°ƒè¯•,ä¸‹é¢æˆ‘ä»¬æä¾›äº†ä¸€ä¸ªç¤ºä¾‹å‡½æ•°.è¿™æ˜¯`raytrace_triangle`çš„ä¸€ä¸ªå®žçŽ°,å…¶ä¸­æœ‰ä¸€äº›é”™è¯¯.ä½ çš„ä»»åŠ¡æ˜¯ä½¿ç”¨è°ƒè¯•å™¨æ‰¾åˆ°é”™è¯¯å¹¶ä¿®å¤å®ƒ(å½“ç„¶æˆ‘çŸ¥é“æˆ‘ä»¬ä¸Šé¢å·²ç»æä¾›äº†solutionä½ åº”è¯¥ä¹Ÿå·²ç»çœ‹è¿‡äº†,ä½†æ˜¯è¿™ä¸ªéƒ¨åˆ†æ˜¯ä¸ºäº†è®­ç»ƒä½ ä½¿ç”¨VSCodeå†…ç½®è°ƒåˆ¶å™¨çš„èƒ½åŠ›,æ‰€ä»¥è¯·å¿˜äº†å‚è€ƒç­”æ¡ˆ!).
::: details æœ‰é”™è¯¯çš„å‡½æ•°
```python
def raytrace_triangle_with_bug(
    rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
    triangle: Float[Tensor, "trianglePoints=3 dims=3"]
) -> Bool[Tensor, "nrays"]:
    '''
    For each ray, return True if the triangle intersects that ray.
    '''
    NR = rays.size[0]

    A, B, C = einops.repeat(triangle, "pts dims -> pts NR dims", NR=NR)

    O, D = rays.unbind(-1)

    mat = t.stack([- D, B - A, C - A])

    dets = t.linalg.det(mat)
    is_singular = dets.abs() < 1e-8
    mat[is_singular] = t.eye(3)

    vec = O - A

    sol = t.linalg.solve(mat, vec)
    s, u, v = sol.unbind(dim=-1)

    return ((u >= 0) & (v >= 0) & (u + v <= 1) & ~is_singular)


intersects = raytrace_triangle_with_bug(rays2d, test_triangle)
img = intersects.reshape(num_pixels_y, num_pixels_z).int()
imshow(img, origin="lower", width=600, title="Triangle (as intersected by rays)")    
```
:::

ä½ å¯ä»¥é€šè¿‡ç‚¹å‡»å•å…ƒæ ¼åº•éƒ¨çš„**Debug cell(è°ƒè¯•å•å…ƒæ ¼)**æ¥è°ƒè¯•.ä½ çš„å•å…ƒæ ¼åº”è¯¥åŒ…å«å®žé™…è¿è¡Œæ—¶å¯¼è‡´é”™è¯¯çš„ä»£ç (è€ŒéžåŒ…å«é”™è¯¯æ¥æºçš„å‡½æ•°).åœ¨è¿è¡Œè°ƒè¯•å™¨ä¹‹å‰,ä½ å¯ä»¥é€šè¿‡å•å‡»è¡Œå·å·¦ä¾§(å•æœºåŽå°†å‡ºçŽ°ä¸€ä¸ªçº¢ç‚¹)æ¥è®¾ç½®æ–­ç‚¹.ç„¶åŽ,ä½ å¯ä»¥ä½¿ç”¨è°ƒè¯•å™¨è¿è¡Œæ—¶å‡ºçŽ°çš„æŒ‰é’®å·¥å…·æ å•æ­¥è°ƒè¯•ä»£ç (å‚é˜…[è¿™é‡Œ](https://pawelgrzybek.com/continue-step-over-step-into-and-step-out-actions-in-visual-studio-code-debugger-explained/)ä»¥äº†è§£æ¯ä¸ªæŒ‰é’®çš„åŠŸèƒ½è¯´æ˜Ž).å½“ç¨‹åºè¿è¡Œåˆ°æ–­ç‚¹æ—¶,ä½ å¯ä»¥ä½¿ç”¨ä»¥ä¸‹å·¥å…·:
- åœ¨å·¦ä¾§è¾¹æ **VARIABLES(å˜é‡)** çª—å£ä¸­æ£€æŸ¥å±€éƒ¨å’Œå…¨å±€å˜é‡.
- åœ¨å·¦ä¾§è¾¹æ **WATCH(è§‚å¯Ÿ)** çª—å£ä¸­æ·»åŠ è¦è§‚å¯Ÿçš„å˜é‡è¡¨è¾¾å¼.
    - ä½ å¯ä»¥åœ¨è¿™é‡Œè¾“å…¥ä»»ä½•è¡¨è¾¾å¼,ä¾‹å¦‚å˜é‡çš„ç±»åž‹æˆ–åˆ—è¡¨çš„é•¿åº¦,è¿™å°†åœ¨ä»£ç å•æ­¥è¿è¡Œä¹‹åŽå®žæ—¶æ›´æ–°.
- é€šè¿‡å°†è¡¨è¾¾å¼è¾“å…¥åˆ°**DEBUG CONSOLE(è°ƒè¯•æŽ§åˆ¶å°)** (å‡ºçŽ°åœ¨å±å¹•åº•éƒ¨)æ¥ä¸€æ¬¡æ€§è®¡ç®—è¡¨è¾¾å¼çš„å€¼.

è¯·æ³¨æ„,ä½ çš„ä»£ç ä¼šåœ¨ä½ æ‰“æ–­ç‚¹çš„é‚£ä¸€è¡Œå¼€å§‹æ‰§è¡Œä¹‹å‰åœæ­¢æ‰§è¡Œ.å› æ­¤å¦‚æžœä½ åœ¨æŸä¸€è¡Œä¸Šå‡ºçŽ°æŠ¥é”™,ä½ éœ€è¦åšçš„å°±æ˜¯ç›´æŽ¥åœ¨è¿™ä¸€è¡Œæ‰“æ–­ç‚¹.

_å¦‚æžœä½ åœ¨VSCodeä¸­ä½¿ç”¨jupyter notebook,é‚£ä¸Šé¢è¿™äº›å†…å®¹çš„åŸºæœ¬å·¥ä½œåŽŸç†éƒ½å·®ä¸å¤š,é™¤äº†ä¸€äº›å°æ›´æ”¹,ä¾‹å¦‚è°ƒè¯•æŒ‰é’®åœ¨å•å…ƒæ ¼å·¦ä¸Šè§’çš„ä¸‹æ‹‰èœå•ä¸­(å¦‚æžœä½ æ‰¾ä¸åˆ°,é‚£ä¹ˆä½ éœ€è¦è¿›å…¥ç”¨æˆ·è®¾ç½®å¹¶æ·»åŠ ä¸€è¡Œ`"notebook.consolidatedRunButton": true`)._

æˆ‘ä»¬è¿˜æƒ³è®¨è®ºæœ‰å…³è°ƒè¯•çš„æ›´å¤šç»†èŠ‚,ä½†æ˜¯è¿™äº›å·²ç»è¶³å¤Ÿæ»¡è¶³å¤§å¤šæ•°éœ€æ±‚.è°ƒè¯•å™¨é€šå¸¸æ˜¯æ¯”printæˆ–è€…assertæ›´æœ‰æ•ˆçš„è°ƒè¯•æ–¹å¼(å°½ç®¡è¿™ä¸¤ä¸ªåœ¨æŸäº›æƒ…å†µä¸‹ä¹Ÿå¾ˆæœ‰å¸®åŠ©).
::: details Answer - è¿™äº›bugæ˜¯ä»€ä¹ˆå’Œå¦‚ä½•ä¿®å¤è¿™äº›bug.
```python
NR = rays.size[0]
```

è¿™é‡Œåº”è¯¥æ˜¯`rays.size(0)`(æˆ–è€…ç­‰ä»·çš„`rays.shape[0]`)`size`æ˜¯ä¸€ä¸ªç±»æ–¹æ³•,éœ€è¦æŽ¥å—ä¸€ä¸ªæ•´æ•°ä½œä¸ºå‚æ•°å¹¶è¿”å›žè¿™ä¸ªç»´åº¦çš„å½¢çŠ¶;`shape`æ˜¯ä¸€ä¸ªå®žä¾‹å±žæ€§å¯ä»¥æŽ¥å—ç´¢å¼•.

è¿™ä¸ªé—®é¢˜å°±ç®—æ²¡æœ‰è°ƒè¯•å™¨ä¹Ÿèƒ½å¾ˆå®¹æ˜“çš„è§£å†³,å› ä¸ºæŠ¥é”™ä¿¡æ¯éžå¸¸è¯¦ç»†.

---

```python
O, D = rays.unbind(-1)
```
æˆ‘ä»¬åœ¨åˆ†è§£é”™è¯¯çš„ç»´åº¦.`rays`çš„å½¢çŠ¶æ˜¯`(nrays, points=2, dims=3)`,è€Œæˆ‘ä»¬å®žé™…ä¸Šæƒ³æ²¿ç€`points`ç»´åº¦åˆ†è§£.æ‰€ä»¥æˆ‘ä»¬åº”è¯¥ç”¨`rays.unbind(1)`.

æˆ‘ä»¬å¯ä»¥é€šè¿‡åœ¨å˜é‡çª—å£è§‚å¯Ÿ`rays`å®žä¾‹å‘çŽ°è¿™ä¸€ç‚¹(ä½ å¯ä»¥ç‚¹å‡»å˜é‡åçš„ä¸‹æ‹‰ç®­å¤´æ¥è§‚å¯Ÿå˜é‡çš„å±žæ€§å€¼,åŒ…æ‹¬`shape`),æˆ–è€…ä½ å¯ä»¥é€šè¿‡åœ¨è°ƒè¯•æŽ§åˆ¶å°è¾“å…¥`rays.shape`æ¥æŸ¥çœ‹å±žæ€§å€¼.è¿™ä¸ªé”™è¯¯åº”è¯¥ä¹Ÿæ˜¯æ˜¾è€Œæ˜“è§çš„(ä½¿ç”¨ç±»åž‹æ£€æŸ¥çš„å¥½ä¾‹å­!).

---

```python
mat = t.stack([- D, B - A, C - A])
```
è¿™é‡Œéœ€è¦åœ¨æœ€åŽå¤šä¸€ä¸ªå‚æ•°`dim=-1`,å› ä¸º`torch.stack`é»˜è®¤æ²¿ç€ç¬¬ä¸€ä¸ªç»´åº¦å †ç§¯å¼ é‡.

è¿™ä¸ªé”™è¯¯å¯èƒ½æ¯”è¾ƒéš¾å‘çŽ°,å› ä¸ºæŠ¥é”™çš„è¡Œåœ¨å®žé™…å‡ºçŽ°é”™è¯¯çš„è¡Œå‰ä¸€è¡Œ.å½“ç„¶,æˆ‘ä»¬ä¹Ÿå¯ä»¥é€šè¿‡åœ¨å˜é‡çª—å£æ£€æŸ¥`mat`å¼ é‡çš„å½¢çŠ¶æ¥å‘çŽ°è¿™ä¸ªé”™è¯¯.

---

è¿™äº›éƒ½æ˜¯ç›¸å¯¹å®¹æ˜“å‘çŽ°çš„é”™è¯¯(å¹¶éžæ‰€æœ‰é”™è¯¯éƒ½ä¼šåœ¨ä»£ç ä¸­æŠ¥é”™,æœ‰äº›å¯èƒ½åªæ˜¯æ„å¤–çš„ç»“æžœ).ä½†å¸Œæœ›è¿™ä¸ªç»ƒä¹ èƒ½è®©ä½ äº†è§£å¦‚ä½•ä½¿ç”¨è°ƒè¯•å™¨.è¿™æ˜¯ä¸€ä¸ªéžå¸¸å¼ºå¤§çš„å·¥å…·,å¯ä»¥èŠ‚çº¦ä½ å¾ˆå¤šæ—¶é—´.
:::

## åŠ è½½Mesh
ä½¿ç”¨æä¾›çš„ä»£ç æ¥åŠ è½½ä¸‰è§’å½¢ç»„æˆçš„çš®å¡ä¸˜.æŒ‰ç…§æƒ¯ä¾‹,ä½¿ç”¨`torch.save`å†™å…¥çš„æ–‡ä»¶éƒ½ä»¥`.pt`ç»“å°¾,ä½†å®žé™…ä¸Šè¿™äº›åªæ˜¯zipæ–‡ä»¶ç½¢äº†.
```python
with open(section_dir / "pikachu.pt", "rb") as f:
    triangles = t.load(f)
```

## æ¸²æŸ“Mesh
å¯¹äºŽæˆ‘ä»¬çš„ç›®æ ‡,meshå°±æ˜¯ä¸€ç»„ä¸‰è§’å½¢,å› æ­¤ä¸ºäº†æ¸²æŸ“å®ƒ,æˆ‘ä»¬å°†åŒæ—¶ä½¿æ‰€æœ‰å…‰çº¿å’Œæ‰€æœ‰ä¸‰è§’å½¢ç›¸äº¤.æˆ‘ä»¬ä¹‹å‰åªæ˜¯è¿”å›žä¸€ä¸ªboolå€¼åˆ¤æ–­ç»™å®šçš„å°„çº¿æ˜¯å¦ä¸Žä¸‰è§’å½¢ç›¸äº¤,ä½†çŽ°åœ¨å¯èƒ½æœ‰å¤šä¸ªä¸‰è§’å½¢ä¸Žç»™å®šçš„å°„çº¿ç›¸äº¤.

å¯¹äºŽæ¯ä¸€æ¡å°„çº¿(åƒç´ ),å¦‚æžœå¯ä»¥,æˆ‘ä»¬å°†è¿”å›žä¸€ä¸ªè¡¨ç¤ºåˆ°ä¸‰è§’å½¢æœ€çŸ­è·ç¦»çš„æµ®ç‚¹å€¼,å¦åˆ™è¿”å›žè¡¨ç¤ºæ— ç©·å¤§çš„ç‰¹æ®Šå€¼`float('inf')`.æˆ‘ä»¬çŽ°åœ¨ä¸ä¼šè¿”å›žå“ªäº›ä¸‰è§’å½¢æ˜¯ç›¸äº¤çš„.

è¯·æ³¨æ„,åˆ°ä¸‰è§’å½¢çš„è·ç¦»ç‰¹æŒ‡**æ²¿xè½´çš„è·ç¦»**,è€Œä¸æ˜¯æ¬§å‡ é‡Œå¾—è·ç¦».

### Exercise-å®Œæˆ`raytrace_mesh`
::: tip TIPS
Difficulty: ðŸ”´ðŸ”´ðŸ”´âšªâšª

Importance: ðŸ”µðŸ”µðŸ”µðŸ”µâšª

ä½ åº”è¯¥èŠ±æœ€å¤š20-25åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.

è¿™æ˜¯æˆ‘ä»¬ä¸€ç›´åœ¨æž„å»ºçš„ä¸»è¦å‡½æ•°,å¹¶ä¸”å®Œæˆä»–æ ‡å¿—ç€è¿™ä¸€èŠ‚æ ¸å¿ƒå†…å®¹çš„å®Œæˆ.ä»–æ¶‰åŠäº†å¤§é‡ä¸Šä¸€ä¸ªç»ƒä¹ ä¸­åº”è¯¥é‡å¤åˆ©ç”¨çš„ä»£ç .
:::

å’Œå…ˆå‰ä¸€æ ·å®Œæˆ`raytrace_mesh`,é‡å¡‘å¹¶å¯è§†åŒ–è¾“å‡º.ä½ çš„çš®å¡ä¸˜ä»¥(0,0,0)ä¸ºä¸­å¿ƒç‚¹,æ‰€ä»¥ä½ åº”è¯¥æŠŠä½ çš„å…‰çº¿å‡ºå‘ç‚¹ç§»åˆ°æ—è¾¹,è‡³å°‘`x=-2`æ¥å®Œæ•´çš„è§‚å¯Ÿä»–.

è¯·è®°ä½,`t.linalg.solve`(å’Œå¤§éƒ¨åˆ†æ‰¹æ“ä½œ)å¯ä»¥æŽ¥å—ä»¥æ‰¹å¤„ç†çš„æ–¹å¼æŽ¥å—å¤šä¸ªç»´åº¦.å…ˆå‰ä½ ä»…ä»…ç”¨`NR`(the number of rays, å…‰çº¿çš„æ•°é‡)è¡¨ç¤ºæ‰¹ç»´åº¦,ä½†æ˜¯çŽ°åœ¨ä½ ä¹Ÿå¯ä»¥ä½¿ç”¨`(NR, NT)`(the number of rays and triangles, å…‰çº¿å’Œä¸‰è§’å½¢çš„æ•°é‡)ä½œä¸ºä½ çš„æ‰¹ç»´åº¦,æ‰€ä»¥ä½ å¯ä»¥ä¸€å£æ°”solveæ‰€æœ‰çš„å…‰çº¿å’Œä¸‰è§’å½¢.
```python
def raytrace_mesh(
    rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
    triangles: Float[Tensor, "ntriangles trianglePoints=3 dims=3"]
) -> Float[Tensor, "nrays"]:
    '''
    For each ray, return the distance to the closest intersecting triangle, or infinity.
    '''
    pass


num_pixels_y = 120
num_pixels_z = 120
y_limit = z_limit = 1

rays = make_rays_2d(num_pixels_y, num_pixels_z, y_limit, z_limit)
rays[:, 0] = t.tensor([-2, 0.0, 0.0])
dists = raytrace_mesh(rays, triangles)
intersects = t.isfinite(dists).view(num_pixels_y, num_pixels_z)
dists_square = dists.view(num_pixels_y, num_pixels_z)
img = t.stack([intersects, dists_square], dim=0)

fig = px.imshow(img, facet_col=0, origin="lower", color_continuous_scale="magma", width=1000)
fig.update_layout(coloraxis_showscale=False)
for i, text in enumerate(["Intersects", "Distance"]): 
    fig.layout.annotations[i]['text'] = text
fig.show()
```

::: details SOLUTION
```python
def raytrace_mesh(
    rays: Float[Tensor, "nrays rayPoints=2 dims=3"],
    triangles: Float[Tensor, "ntriangles trianglePoints=3 dims=3"]
) -> Float[Tensor, "nrays"]:
    '''
    For each ray, return the distance to the closest intersecting triangle, or infinity.
    '''
    # SOLUTION
    NR = rays.size(0)
    NT = triangles.size(0)

    # Each triangle is [[Ax, Ay, Az], [Bx, By, Bz], [Cx, Cy, Cz]]
    triangles = einops.repeat(triangles, "NT pts dims -> pts NR NT dims", NR=NR)
    A, B, C = triangles
    assert A.shape == (NR, NT, 3)

    # Each ray is [[Ox, Oy, Oz], [Dx, Dy, Dz]]
    rays = einops.repeat(rays, "NR pts dims -> pts NR NT dims", NT=NT)
    O, D = rays
    assert O.shape == (NR, NT, 3)

    # Define matrix on left hand side of equation
    mat: Float[Tensor, "NR NT 3 3"] = t.stack([- D, B - A, C - A], dim=-1)
    # Get boolean of where matrix is singular, and replace it with the identity in these positions
    dets: Float[Tensor, "NR NT"] = t.linalg.det(mat)
    is_singular = dets.abs() < 1e-8
    mat[is_singular] = t.eye(3)

    # Define vector on the right hand side of equation
    vec: Float[Tensor, "NR NT 3"] = O - A

    # Solve eqns (note, s is the distance along ray)
    sol: Float[Tensor, "NR NT 3"] = t.linalg.solve(mat, vec)
    s, u, v = sol.unbind(-1)

    # Get boolean of intersects, and use it to set distance to infinity wherever there is no intersection
    intersects = ((u >= 0) & (v >= 0) & (u + v <= 1) & ~is_singular)
    s[~intersects] = float("inf") # t.inf

    # Get the minimum distance (over all triangles) for each ray
    return s.min(dim=-1).values
```
:::