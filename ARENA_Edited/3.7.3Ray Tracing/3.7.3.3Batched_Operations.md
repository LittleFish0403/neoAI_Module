# æ‰¹é‡æ“ä½œ(Batched Operations)
## æ‰¹é‡å°„çº¿-çº¿æ®µäº¤ç‚¹æ£€æµ‹
æ¥ä¸‹æ¥,å®ç°å°„çº¿-çº¿æ®µäº¤ç‚¹æ£€æµ‹çš„æ‰¹å¤„ç†ç‰ˆæœ¬.ä»–æœ‰å¤šæ¡å°„çº¿å’Œå¤šæ¡çº¿æ®µ,å¹¶ä¸ºæ¯æ¡å°„çº¿è¿”å›ä¸€ä¸ªboolå€¼,è¡¨ç¤ºæ˜¯å¦æœ‰**ä»»ä½•**çº¿æ®µå’Œè¯¥å°„çº¿ç›¸äº¤.

æ³¨æ„,åœ¨æ‰¹é‡å¤„ç†ç‰ˆæœ¬ä¸­,æˆ‘ä»¬ä¸å¸Œæœ›solveæ–¹ç¨‹æ—¶ä»…ä»…å› ä¸ºæŸäº›æ–¹ç¨‹æ— è§£å°±æŠ›å‡ºå¼‚å¸¸,è¿™äº›æ— è§£çš„æ–¹ç¨‹åº”è¯¥ç›´æ¥è¿”å›False.
### Tip - çœç•¥å·
ä½ å¯ä»¥åœ¨ç´¢å¼•åˆ‡ç‰‡è¡¨è¾¾å¼ä¸­ä½¿ç”¨çœç•¥å·`...`æ¥é¿å…é‡å¤ä½¿ç”¨`:`,å¹¶ä¸”å¯ä»¥å…¼å®¹ç»´åº¦æ•°ä¸åŒçš„è¾“å…¥å¼ é‡.

ä¾‹å¦‚,`x[..., 0]`å’Œ`x[;, :, 0]`åœ¨`x`æ˜¯ä¸‰ç»´å¼ é‡çš„å‰æä¸‹æ˜¯ç­‰ä»·çš„.è‹¥`x`æ˜¯å››ç»´å¼ é‡é‚£å’Œ`x[:, :, :, 0]`æ˜¯ç­‰ä»·çš„.

### Tip - å¼ é‡ä¸­æŒ‰å…ƒç´ é€»è¾‘è¿ç®—
å¯¹äºå¸¸è§„çš„boolå€¼,å…³é”®å­—`and`,`or`å’Œ`not`å¯ä»¥ç”¨äºé€»è¾‘è¿ç®—,è€Œ`&`,`|`å’Œ`~`ä¼šå¯¹è¾“å…¥æ•°å­—æŒ‰ä½æ‰§è¡Œä¸æˆ–éè¿ç®—.ä¾‹å¦‚`0b10001 | 0b11000`ç»“æœæ˜¯`0b11001`,å³åè¿›åˆ¶ä¸‹çš„`25`.

ä¸å¹¸çš„æ˜¯,Pythonä¸­ä¸å…è®¸ç±»é‡è½½å…³é”®å­—.å› æ­¤å¦‚æœ`x`å’Œ`y`çš„ç±»å‹ä¸º`torch.Tensor`,é‚£ä¹ˆ`x and y`å¯èƒ½ä¸ä¼šæ‰§è¡Œä½ æƒ³è¦çš„æ“ä½œ,å³æŒ‰å…ƒç´ æ‰§è¡Œ`x[i] and y[i]`è¿ç®—.å®é™…ä¸Šä»–ä¼šå°è¯•æŠŠ`x`å¼ºåˆ¶è½¬æ¢ä¸ºboolå€¼,è¿™ä¼šæŠ¥é”™.

ä½œä¸ºä¸€ç§è§£å†³æ–¹æ³•,PyTorch(å’ŒNumPy)é€‰æ‹©é‡è½½ä½è¿ç®—ç¬¦,ä½†è®©ä»–ä»¬å®é™…ä¸Šç­‰æ•ˆäºæŒ‰å…ƒç´ è¿›è¡Œé€»è¾‘è¿ç®—,å› ä¸ºé€šå¸¸ä½ ä¸ä¼šè®©çŸ©é˜µä¸­çš„å€¼ä½œä½è¿ç®—.å› æ­¤æƒ³è¦å¾—åˆ°`x[i] and y[i]`ç»“æœçš„æ­£ç¡®è¡¨è¾¾æ–¹å¼åº”è¯¥æ˜¯`x & y`.

åœ¨æ¶‰åŠé€»è¾‘è¿ç®—æ—¶è¿˜æœ‰ä¸ªé—®é¢˜æ˜¯**è¿ç®—ä¼˜å…ˆçº§**.ä¾‹å¦‚`v >= 0 & v <= 1`å®é™…ä¸Šè®¡ç®—é¡ºåºæ˜¯`(v >= (0 & v)) <= 1`,å› ä¸º`&`æœ‰æ›´é«˜çš„è¿ç®—ä¼˜å…ˆçº§.å¦‚æœå‡ºç°äº†æœ‰ç–‘é—®çš„ç»“æœè¯·ä½¿ç”¨æ‹¬å·å¼ºåˆ¶è®©å¼å­æŒ‰ç…§ä½ çš„æƒ³æ³•è¿ç®—:`(v >= 0) & (v <= 1)`.

### Tip - `einops`
Einopsæ˜¯ä¸€ä¸ªå¾ˆæœ‰ç”¨çš„åº“,æ˜å¤©æˆ‘ä»¬ä¼šå¯¹å…¶è¿›è¡Œæ›´æ·±å…¥çš„ç ”ç©¶.ç›®å‰ä½ å”¯ä¸€éœ€è¦äº†è§£çš„é‡è¦çš„å‡½æ•°å°±æ˜¯`einops.repeat`.è¿™ä¸ªå‡½æ•°å°†å°†å¼ é‡å’Œå­—ç¬¦ä¸²ä½œä¸ºå‚æ•°,å¹¶è¿”å›ä¸€ä¸ªæ²¿ç€ç»™å®šç»´åº¦é‡å¤çš„æ–°å¼ é‡.ä¾‹å¦‚,ä»¥ä¸‹ä»£ç å±•ç¤ºäº†å¦‚ä½•æ²¿ç€æœ€åä¸€ä¸ªç»´åº¦é‡å¤äºŒç»´å¼ é‡:
```python
x = t.randn(2, 3)
x_repeated = einops.repeat(x, 'a b -> a b c', c=4)

assert x_repeated.shape == (2, 3, 4)
for c in range(4):
    t.testing.assert_close(x, x_repeated[:, :, c])
```

_(å‡½æ•°`t.testing.assert_close`ä¼šæ£€æŸ¥ä¸¤ä¸ªå¼ é‡å½¢çŠ¶æ˜¯å¦ç›¸åŒ,ä¸”æ‰€æœ‰å…ƒç´ å€¼æ˜¯å¦ç›¸åŒæˆ–ä»…æœ‰å¾®å°çš„è¯¯å·®.)_

### Tip - é€»è¾‘çº¦ç®€(Logical Reductions)
åœ¨åŸç‰ˆçš„Pythonä¸­,å¦‚æœä½ æœ‰ä¸€ä¸ªåˆ—è¡¨çš„åˆ—è¡¨å¹¶ä¸”æƒ³çŸ¥é“æ¯ä¸€è¡Œçš„æ‰€æœ‰å…ƒç´ æ˜¯å¦å‡ä¸ºTrue,ä½ å¯ä»¥ä½¿ç”¨åˆ—è¡¨è§£æå¼ä¾‹å¦‚`[any(row) for row in rows]`.åœ¨PyTorchä¸­æ‰§è¡Œæ­¤ç±»ä¼¼æ“ä½œçš„æœ‰æ•ˆæ–¹æ³•æ˜¯ä½¿ç”¨`torch.any()`æˆ–è€…ç­‰æ•ˆçš„å¼ é‡çš„`.any()`æ–¹æ³•,ä»–çš„å‚æ•°æ˜¯éœ€è¦å‡å°‘çš„ç»´åº¦.ç±»ä¼¼çš„,è¿˜æœ‰`torch.all()`å’Œ`.all()`æ–¹æ³•.è¿™ä¸¤ç§æ–¹æ³•éƒ½è¦æ¥å—ä¸€ä¸ª`dim`å‚æ•°è¡¨ç¤ºéœ€è¦å‡å°‘çš„ç»´åº¦.

::: details Aside - å¼ é‡æ–¹æ³•
PyTorch(å’ŒNumpy)ä¸­çš„å¤§å¤šæ•°å‡½æ•°,ä¾‹å¦‚`torch.any(tensor, ...)`(å³å°†å¼ é‡ä½œä¸ºç¬¬ä¸€ä¸ªå‚æ•°çš„å‡½æ•°)éƒ½æœ‰ä¸€ä¸ªç­‰æ•ˆçš„å¼ é‡æ–¹æ³•`tensor.any(...)`.åœ¨è¯¾ç¨‹çš„åé¢æˆ‘ä»¬ä¼šçœ‹åˆ°æ›´å¤šæ­¤ç±»å‡½æ•°çš„ä¾‹å­.
:::

### Tip - å¹¿æ’­
å¹¿æ’­æ˜¯å½“ä½ å¯¹ä¸¤ä¸ªå¼ é‡æ‰§è¡Œæ“ä½œæ—¶å¯èƒ½å‘ç”Ÿçš„æƒ…å†µ,å…¶ä¸­ä¸€ä¸ªå¼ é‡å°ºå¯¸è¾ƒå°,ä½†æ˜¯å¯ä»¥æ²¿ç€å°ºå¯¸è¾ƒå¤§çš„å¼ é‡ç»´åº¦å¤åˆ¶æ¥è®©æ“ä½œå¯ä»¥è¿›è¡Œ.ä¸‹é¢æ˜¯ä¸€ä¸ªç¤ºä¾‹(å…¶ä¸­`B`æ²¿ç€`A`çš„ç¬¬ä¸€ä¸ªç»´åº¦å¤åˆ¶):
```python
A = t.randn(2, 3)
B = t.randn(3)
AplusB = A + B

assert AplusB.shape == (2, 3)
for i in range(2):
    t.testing.assert_close(AplusB[i], A[i] + B)
```

å¹¿æ’­çš„æ˜ç¡®å«ä¹‰æœ‰ç‚¹éš¾è®²æ˜ç™½,æˆ‘ä»¬ä¼šåœ¨è¯¾ç¨‹åé¢è¯¦ç»†è®¨è®º.å¦‚æœä½ æƒ³æŸ¥çœ‹å®Œæ•´å†…å®¹å¯ä»¥ç‚¹å‡»å±•å¼€ä¸‹é¢å†…å®¹.ç°åœ¨ä½ éœ€è¦äº†è§£çš„æœ€é‡è¦çš„ä¸€ç‚¹æ˜¯-_ç»´åº¦ è¢«é™„åŠ åˆ°äº†å°ºå¯¸è¾ƒå°çš„å¼ é‡`B`çš„**å¼€å¤´**,å¹¶æ²¿ç€è¿™äº›å°ºå¯¸å¤åˆ¶ç›´åˆ°å…¶å½¢çŠ¶å’Œå°ºå¯¸è¾ƒå¤§çš„å¼ é‡`A`ç›¸åŒ¹é…._
::: details Aside - å¹¿æ’­çš„ç»†èŠ‚
å¦‚æœä½ å°è¯•å»å¹¿æ’­å¼ é‡`A`å’Œ`B`,é‚£ä¹ˆä¼šå‘ç”Ÿä¸‹é¢çš„äº‹æƒ…:

- ç»´åº¦è¾ƒå°çš„å¼ é‡åœ¨å·¦ä¾§å¡«å……å¤§å°ä¸º1çš„ç»´åº¦.
- ä¸€æ—¦ä¸¤ä¸ªå¼ é‡çš„ç»´åº¦ç›¸åŒ,å°†æ£€æŸ¥å…¼å®¹æ€§:
  - å¦‚æœä¸¤ä¸ªå¼ é‡å°ºå¯¸ç›¸åŒ,æˆ–è€…ä¸åŒçš„å°ºå¯¸å¯¹åº”è½´çš„å¤§å°ä¸º1,é‚£ä¹ˆä»–ä»¬æ˜¯å…¼å®¹çš„(å¯¹åä¸€ç§æƒ…å†µ,æˆ‘ä»¬å°†æ²¿ç€è¯¥ç»´åº¦é‡å¤å¤§å°ä¸º1çš„å¼ é‡,ç›´åˆ°å®ƒä¸è¾ƒå¤§ç»´åº¦çš„å°ºå¯¸ç›¸åŒ).
  - å¦‚æœä¸¤ä¸ªå¼ é‡ä¸å…¼å®¹åˆ™æ— æ³•å¹¿æ’­.

ä¸¾ä¸ªä¾‹å­,åœ¨ä¸Šé¢çš„ç¤ºä¾‹ä¸­,ç¬¬ä¸€ä¸ª`B`å·¦è¾¹è¢«å¡«å……æˆäº†`(1, 3)`,æ¥ä¸‹æ¥æ²¿ç€ç¬¬ä¸€ä¸ªç»´åº¦å¤åˆ¶å¼ é‡ä½¿å¾—æœ€ç»ˆå½¢çŠ¶æˆä¸º`(2, 3)`,è¿™æ ·å°±ä¸`A`çš„å½¢çŠ¶ä¸€è‡´å¯ä»¥ç›¸åŠ .

å¦ä¸€æ–¹é¢,å¦‚æœ`B`çš„å½¢çŠ¶æ˜¯`(2,)`é‚£ä¹ˆå°±æ— æ³•å¹¿æ’­,å› ä¸ºæ–°ç»´åº¦æ— æ³•è¢«æ·»åŠ åˆ°å¼ é‡å³è¾¹.
:::

::: tip å¯¹ä¸Šé¢æ‰€æœ‰Tipsçš„çœæµ
- åœ¨è¡¨è¾¾ç´¢å¼•åˆ‡ç‰‡æ—¶ä½¿ç”¨`...`æ¥é¿å…é‡å¤è¾“å…¥`:`.
- ä½¿ç”¨`&`,`|`å’Œ`~`æ¥åœ¨å¼ é‡ä¸­è¿›è¡ŒæŒ‰å…ƒç´ é€»è¾‘è¿ç®—.
- ä½¿ç”¨æ‹¬å·æ¥å¼ºåˆ¶è®©å¼å­æŒ‰ç…§ä½ çš„æƒ³æ³•è¿ç®—.
- ä½¿ç”¨`torch.any()`å’Œ`any.()`æ¥è¿›è¡Œé€»è¾‘çº¦ç®€(é€šè¿‡ä½¿ç”¨å‚æ•°`dim`,ä½ å¯ä»¥åªåœ¨ä¸€ä¸ªç»´åº¦ä¸Šæ‰§è¡Œè¿™ä¸ªæ“ä½œ).
- å¦‚æœä½ æ­£åœ¨å°è¯•å¹¿æ’­å¼ é‡`A`å’Œ`B`(`B`çš„ç»´åº¦æ•°æ›´å°‘),è¿™ä¸ªæ“ä½œåªæœ‰åœ¨`B`çš„å½¢çŠ¶å’Œ`A`çš„ **æœ€åå‡ ä¸ª** ç»´åº¦å½¢çŠ¶ç›¸åŒæ—¶æ‰èƒ½è¿›è¡Œ(åœ¨è¿™ç§æƒ…å†µä¸‹,`B`å°†æ²¿ç€`A`å‰é¢å‡ ä¸ªç»´åº¦çš„å½¢çŠ¶å¤åˆ¶).
:::

### Exercise - å®Œæˆ`intersect_rays_1d`
::: tip TIPS
Difficulty: ğŸ”´ğŸ”´ğŸ”´ğŸ”´âšª

Importance: ğŸ”µğŸ”µğŸ”µğŸ”µâšª

ä½ åº”è¯¥èŠ±æœ€å¤š25-30åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.

è¿™æ˜¯ä»Šå¤©æœ€æœ‰éš¾åº¦çš„ç»ƒä¹ ,åœ¨éš¾åº¦ä¸Šè·¨åº¦å¯èƒ½æ˜¯æœ€å¤§çš„,è¯·ä¸è¦è¿‡æ—©çš„æ°”é¦.

:::

è€ƒè™‘åˆ°ä¸Šé¢æ‰€æœ‰çš„æŠ€å·§,ç°åœ¨ä½ åº”è¯¥èƒ½å¤Ÿå®Œæˆ`intersect_rays_1d`å‡½æ•°äº†,å³`intersect_ray_1d`çš„æ‰¹å¤„ç†ç‰ˆæœ¬.è¯¥å‡½æ•°å¯¹äºæ¯ä¸€æ¡å°„çº¿å°†è¿”å›ä¸€ä¸ªboolå€¼è¡¨ç¤ºå°„çº¿æ˜¯å¦å’Œä»»ä½•çº¿æ®µæœ‰äº¤ç‚¹.
```python
def intersect_rays_1d(rays: Float[Tensor, "nrays 2 3"], segments: Float[Tensor, "nsegments 2 3"]) -> Bool[Tensor, "nrays"]:
    '''
    For each ray, return True if it intersects any segment.
    '''
    pass


tests.test_intersect_rays_1d(intersect_rays_1d)
tests.test_intersect_rays_1d_special_case(intersect_rays_1d)
```
:::details æ•‘ä¸€æ•‘!æˆ‘ä¸çŸ¥é“è¯¥æ€ä¹ˆä¸ç”¨å¾ªç¯å®Œæˆè¿™ä¸ªå‡½æ•°.
é¦–å…ˆ,`rays.shape == (NR, 2, 3)`å†`segments.shape == (NS, 2, 3)`.è¯•è¯•åœ¨è¿™ä¸¤ä¸ªå¼ é‡ä¸Šç”¨ç”¨`einops.repeat`,è¿™æ ·å¯ä»¥è®©ä»–ä»¬çš„å½¢çŠ¶éƒ½å˜æˆ(NR, NS, 2, 3),æ¥ä¸‹æ¥ä½ å°±å¯ä»¥é€ çŸ©é˜µå¹¶æ‰¹é‡solveäº†.
:::

::: details æ•‘ä¸€æ•‘!æˆ‘ä¸çŸ¥é“æ€ä¹ˆå¤„ç†è¡Œåˆ—å¼ä¸º0çš„æƒ…å†µ.
ä½ å¯ä»¥ç”¨`t.linalg.det`è®¡ç®—çŸ©é˜µæˆ–æ‰¹é‡çŸ©é˜µçš„è¡Œåˆ—å¼. *(é™·é˜±: è¡Œåˆ—å¼ä¸ä¼šå®Œå…¨ç­‰äº0,ä½†æ˜¯ä½ å¯ä»¥æ£€æŸ¥å®ƒæ˜¯å¦ååˆ†æ¥è¿‘0,ä¾‹å¦‚`det.abs() < 1e-6`)* .è¿™ä¼šè¿”å›ä¸€ä¸ªboolå€¼æ©ç çŸ©é˜µå‘Šè¯‰ä½ å“ªäº›çŸ©é˜µæ˜¯å¥‡å¼‚çš„.

ä½ å¯ä»¥æŠŠæ‰€æœ‰å¥‡å¼‚çŸ©é˜µè®¾æˆå•ä½çŸ©é˜µ(è¿™å¯ä»¥é¿å…æŠ¥é”™),ç„¶ååœ¨æœ€åä½ å¯ä»¥å†æ¬¡ä½¿ç”¨boolå€¼æ©ç çŸ©é˜µæ¥å°†é‚£äº›å¥‡å¼‚çŸ©é˜µå¯¹åº”çš„ç›¸äº¤æƒ…å†µè®¾ç½®ä¸º`False`.
:::

::: details æ•‘ä¸€æ•‘!æˆ‘ä¸çŸ¥é“æ€ä¹ˆå¤„ç†è¡Œåˆ—å¼ä¸º0çš„çŸ©é˜µçš„æƒ…å†µäº†.
åœ¨åˆ›å»ºçŸ©é˜µæ–¹ç¨‹å,ä½ åº”å½“æœ‰ä¸€æ‰¹å½¢çŠ¶ä¸º`(NR, NS, 2, 2)`çš„çŸ©é˜µ.å³å¯¹äºæ¯ä¸ª`mat[i, j, :, :]`éƒ½ç±»ä¼¼ä¸ä¸Šä¸€é¡µçš„ç­‰å¼å·¦è¾¹éƒ¨åˆ†.

è°ƒç”¨`t.linalg.det(mat)`å°†è¿”å›ä¸€ä¸ªå½¢çŠ¶ä¸º`(NR, NS)`çš„æ•°ç»„,å…¶ä¸­åŒ…å«æ¯ä¸ªçŸ©é˜µçš„è¡Œåˆ—å¼å€¼.ä½ å¯ä»¥ç”¨è¿™ä¸ªå€¼æ¥æ„é€ å¥‡å¼‚çŸ©é˜µçš„æ©ç . *(é™·é˜±:è¡Œåˆ—å¼è§£å‡ºæ¥ä¸ä¼šå®Œå…¨ä¸º0,ä½†æ˜¯ä½ å¯ä»¥æ£€æŸ¥å®ƒæ˜¯å¦ååˆ†æ¥è¿‘0,ä¾‹å¦‚`det.abs() < 1e-6`)* .

ä½¿ç”¨è¯¥æ©ç ä½œä¸º`mat`çš„ç´¢å¼•å°†è¿”å›å½¢çŠ¶ä¸º`(x, 2, 2)`çš„æ•°ç»„,å…¶ä¸­ç¬¬0ç»´ä¼šç´¢å¼•åˆ°æ‰€æœ‰çš„å¥‡å¼‚çŸ©é˜µ.æ­£å¦‚æˆ‘ä»¬ä¹‹å‰åœ¨å¹¿æ’­éƒ¨åˆ†è®¨è®ºçš„å†…å®¹,è¿™æ„å‘³ç€æˆ‘ä»¬å¯ä»¥ä½¿ç”¨å¹¿æ’­å°†è¿™äº›å¥‡å¼‚çŸ©é˜µè®¾ç½®ä¸ºå•ä½çŸ©é˜µ.
```python 
mat[is_singular] = t.eye(2)
```
:::

::: details SOLUTION
```python 
def intersect_rays_1d(rays: Float[Tensor, "nrays 2 3"], segments: Float[Tensor, "nsegments 2 3"]) -> Bool[Tensor, "nrays"]:
    '''
    For each ray, return True if it intersects any segment.
    '''
    # SOLUTION
    NR = rays.size(0)
    NS = segments.size(0)

    # Get just the x and y coordinates
    rays = rays[..., :2]
    segments = segments[..., :2]

    # Repeat rays and segments so that we can compuate the intersection of every (ray, segment) pair
    rays = einops.repeat(rays, "nrays p d -> nrays nsegments p d", nsegments=NS)
    segments = einops.repeat(segments, "nsegments p d -> nrays nsegments p d", nrays=NR)

    # Each element of `rays` is [[Ox, Oy], [Dx, Dy]]
    O = rays[:, :, 0]
    D = rays[:, :, 1]
    assert O.shape == (NR, NS, 2)

    # Each element of `segments` is [[L1x, L1y], [L2x, L2y]]
    L_1 = segments[:, :, 0]
    L_2 = segments[:, :, 1]
    assert L_1.shape == (NR, NS, 2)

    # Define matrix on left hand side of equation
    mat = t.stack([D, L_1 - L_2], dim=-1)
    # Get boolean of where matrix is singular, and replace it with the identity in these positions
    dets = t.linalg.det(mat)
    is_singular = dets.abs() < 1e-8
    assert is_singular.shape == (NR, NS)
    mat[is_singular] = t.eye(2)

    # Define vector on the right hand side of equation
    vec = L_1 - O

    # Solve equation, get results
    sol = t.linalg.solve(mat, vec)
    u = sol[..., 0]
    v = sol[..., 1]

    # Return boolean of (matrix is nonsingular, and solution is in correct range implying intersection)
    return ((u >= 0) & (v >= 0) & (v <= 1) & ~is_singular).any(dim=-1)
```
:::

### ä½¿ç”¨GPTç†è§£ä»£ç 
_è¯·æ³¨æ„,ç›®å‰LLMé¢†åŸŸå‘å±•æå¿«,æ‰€ä»¥è¿™ä¸ªéƒ¨åˆ†çš„å†…å®¹å¯èƒ½åœ¨æŸä¸ªæ—¶åˆ»ä¹‹åå°±è¿‡æ—¶äº†!(æ¯”å¦‚ç°åœ¨openaiå°±ä¸å¼€æ”¾GPT-3.5äº†,å…è´¹ç”¨æˆ·åªå‰©ä¸‹GPT-4oå¯ä»¥é€‰æ‹©.ä½†æ˜¯ä¸‹é¢æœ‰å…³GPT-3.5çš„å†…å®¹å¯¹äºGPT-4oè¿˜æ˜¯é€‚ç”¨çš„.)_

ç°åœ¨è®©æˆ‘ä»¬çœ‹ä¸€ä¸ªä½¿ç”¨GPTè¾…åŠ©codingçš„ç®€å•ç¤ºä¾‹:**ä½¿ç”¨GPTæ¥ç†è§£ä»£ç **.å»ºè®®ä½ é˜…è¯»Siddharth Hiregowdaraæœ€è¿‘å‘è¡¨çš„[Lesswrongè´´å­](https://www.lesswrong.com/posts/ptY6X3BdW4kgqpZFo/using-gpt-4-to-understand-code),è¿™é‡Œè¯¦ç»†è®²è¿°äº†ä»–ä½¿ç”¨GPTè¾…åŠ©ç†è§£ä»£ç çš„æµç¨‹.è¿™åœ¨GPT-4ä¸Šæ•ˆæœæœ€å¥½,ä½†æ˜¯åœ¨GPT-3.5ä¸Šå¯¹äºç®€å•çš„é—®é¢˜ä¹ŸåŒæ ·æœ‰æ•ˆ(è¯·å‚è€ƒä¸‹é¢çš„å†…å®¹).

é¦–å…ˆ,ä½ åº”è¯¥æåˆ°ä¸€ä¸ªèƒ½ç”¨GPTçš„è´¦å·.æ¥ä¸‹æ¥,è¯•è¯•è®©GPT-3.5/4è§£é‡Šä¸Šé¢çš„å‡½æ•°.ä½ å¯ä»¥ç”¨ç±»ä¼¼ä¸‹é¢çš„promptæ¥æé—®:
```
Explain this Python function, line by line. You should break up your explanation by inserting sections of the code.

def intersect_rays_1d(rays: Float[Tensor, "nrays 2 3"], segments: Float[Tensor, "nsegments 2 3"]) -> Bool[Tensor, "nrays"]:
    NR = rays.size(0)
    NS = segments.size(0)
    rays = rays[..., :2]
    ...
```

æˆ‘å‘ç°åˆ æ‰æ³¨é‡Šé€šå¸¸ä¼šæ›´æœ‰å¸®åŠ©,å› ä¸ºè¿™æ ·GPTä¼šç”¨è‡ªå·±çš„è¯å›ç­”,è€Œä¸ä»…ä»…æ˜¯é‡å¤æ³¨é‡Šçš„å†…å®¹(è€Œä¸”æ³¨é‡Šæœ‰æ—¶å€™ä¼šè®©ä»–æ„Ÿåˆ°å›°æƒ‘).

ä¸€æ—¦ä½ å¾—åˆ°äº†å›ç­”,ä½ å¯ä»¥è€ƒè™‘é—®ä»¥ä¸‹çš„é—®é¢˜:
- Can you suggest ways to improve the code?(ä½ èƒ½ç»™æˆ‘æ”¹è¿›è¿™ä¸ªä»£ç çš„å»ºè®®å—?)
    - GPT-4å»ºè®®ä½¿ç”¨æ›´é•¿çš„æ–‡æ¡£å­—ç¬¦ä¸²å’Œæ›´æœ‰æè¿°æ€§çš„å˜é‡åç§°.
- Can you explain why the line `mat[is_singular] = t.eye(2)` works?(ä½ å¯ä»¥è§£é‡Šä¸€ä¸‹ä¸ºä»€ä¹ˆ`mat[is_singular] = t.eye(2)`è¿™è¡Œæ˜¯å¦‚ä½•å·¥ä½œçš„å—?)
    - GPT-4ç»™äº†æˆ‘ä¸€ä¸ªæ­£ç¡®ä¸”éå¸¸è¯¦ç»†çš„è§£é‡Š,æ¶‰åŠå¹¿æ’­å’Œå¼ é‡å½¢çŠ¶.

ä½¿ç”¨GPTç®—ä½œå¼Šå—?å¦‚æœä½ åœ¨é‡åˆ°é—®é¢˜çš„ç¬¬ä¸€ååº”æ˜¯æ‰¾GPTè€Œä¸æ˜¯å°è¯•è‡ªå·±ç†è§£ä»£ç ,é‚£å¯èƒ½ç¡®å®æ˜¯ä½œå¼Š.ä½†æ˜¯è¿™é‡Œè¦æŒ‡å‡º[ç®€å•æ¨¡å¼](https://www.lesswrong.com/posts/nJPtHHq6L7MAMBvRK/play-in-easy-mode)å’Œ[å›°éš¾æ¨¡å¼](https://www.lesswrong.com/posts/7hLWZf6kFkduecH2g/play-in-hard-mode)çš„åŒºåˆ«.æŸäº›æƒ…å†µä¸‹,åœ¨ç»§ç»­ä¸‹ä¸€æ­¥ä¹‹å‰å¯¹é—®é¢˜è¿›è¡Œä¸€æ®µæ—¶é—´çš„æ€è€ƒæ˜¯å¾ˆæœ‰ä»·å€¼çš„,å› ä¸ºè¿™ç§æ·±æ€ç†Ÿè™‘å¯ä»¥è®©ä½ æˆä¸ºä¸€åæ›´å¥½çš„ç§‘ç ”è€…æˆ–å·¥ç¨‹å¸ˆ(ä¾‹å¦‚,å½“ä½ åœ¨å¯¹transformerè¿›è¡Œæœºç†è§£é‡Šæ—¶æ€è€ƒä¸€ä¸ªç¯èŠ‚æ˜¯å¦‚ä½•å·¥ä½œçš„å‡è®¾æ—¶,æˆ–è€…åœ¨å®ç°æŸäº›RLç®—æ³•æ—¶æ€è€ƒå“ªç§æ•°æ®ç»“æ„æœ€é€‚åˆä½ çš„ç”¨ä¾‹).ä½†è¿˜æœ‰ä¸€äº›æƒ…å†µ(æ¯”å¦‚ç›®å‰è¿™ç§æƒ…å†µ),ä½ å¯ä»¥ä»GPTé€Ÿé€šä¸­è·å¾—æ›´å¤šçŸ¥è¯†æ¥äº†è§£ä¸€äº›ä»£ç æˆ–æ¦‚å¿µ,å¹¶å°†ä½ çš„ç†è§£åº”ç”¨åˆ°åç»­ç»ƒä¹ ä¸­.æ‰¾åˆ°å¹³è¡¡ç‚¹å¾ˆé‡è¦!

#### ä»€ä¹ˆæ—¶å€™ç”¨GPT-3.5,ä»€ä¹ˆæ—¶å€™ç”¨GPT-4
GPT-3.5å’Œ4åœ¨ä¸åŒæƒ…å†µä¸‹å„æœ‰ä¼˜ç¼ºç‚¹.GPT-3.5åœ¨é€Ÿåº¦ä¸Šæ¯”èµ·GPT-4æœ‰å¾ˆå¤§ä¼˜åŠ¿,å¹¶ä¸”åœ¨ç®€å•é—®é¢˜ä¸ŠåŒæ ·è¡¨ç°è‰¯å¥½.å¦‚æœä½ æƒ³è®©GPTå®Œæˆçš„ä»»åŠ¡æ˜¯ç”¨Copilotå°±èƒ½å¹²çš„,é‚£ä½ æœ€å¥½ä½¿ç”¨GPT-3.5è€Œä¸æ˜¯GPT-4.

å¦ä¸€æ–¹é¢,GPT-4åœ¨ç”Ÿæˆè¿è´¯ä»£ç æ–¹é¢æ›´æœ‰ä¼˜åŠ¿(å°½ç®¡æˆ‘ä»¬ä¸å¸Œæœ›ä½ åœ¨è¿™ä¸ªé˜¶æ®µå°±å¤§é‡ä½¿ç”¨GPT-4ç”Ÿæˆä»£ç ),å¹¶ä¸”åœ¨æ€»ä½“ä¸Šæ›´æ“…é•¿ç”¨æ›´å°‘çš„promptå·¥ç¨‹æŠ€å·§å°±èƒ½å“åº”å¤æ‚ä»»åŠ¡.

#### ä½¿ç”¨GPTçš„é¢å¤–ç¬”è®°(æ¥è‡ªJoseph Bloom)
- ChatGPTè¿‡äºå‹å¥½äº†.å¦‚æœä½ ç»™ä»–ç³Ÿç³•çš„ä»£ç ,ä»–ä¸ä¼šå‘Šè¯‰ä½ è¿™æ˜¯ä¸€å¨,æ‰€ä»¥ä½ åº”è¯¥é¼“åŠ±ä»–æä¾›åé¦ˆå’Œ/æˆ–æƒ³ä½ å±•ç¤ºä¼˜ç§€ä»£ç çš„ç¤ºä¾‹.ç‰¹åˆ«æ˜¯å¯¹äºåˆå­¦è€…ä½¿ç”¨GPTæ—¶,é‡è¦çš„æ˜¯çŸ¥é“å¦‚ä½•è®©ä»–å¯¹ä½ ä¸¥æ ¼ä¸€ç‚¹.
- GPTéå¸¸æ“…é•¿å†™æµ‹è¯•ä»£ç (è®©ä»–ç»™ä½ çš„å‡½æ•°å†™æµ‹è¯•ä»£ç é€šå¸¸æ¯”ç›´æ¥é—®ä»–ä»£ç æ˜¯å¦æ­£ç¡®è¦å¥½),é‡æ„ä»£ç (è¯†åˆ«ä»£ç ä¸­çš„é‡å¤ä»»åŠ¡å¹¶æå–ä»–ä»¬)å’Œå˜é‡å‘½å.è¿™äº›éƒ½å€¼å¾—ä½ å»å°è¯•å‡ æ¬¡çœ‹çœ‹ä»–ä»¬æœ‰å¤šæœ‰ç”¨.
- GPT-4å¯ä»¥å¾ˆå¥½çš„å¤„ç†ä¸€æ•´ä¸ªæ¨¡å—å’Œè„šæœ¬,æ‰€ä»¥è¯·æ¯«ä¸çŠ¹è±«çš„ä¸Šä¼ ä»–ä»¬.å½“ä½ å¼€å§‹åœ¨GitHubä¸Šç®¡ç†å­˜å‚¨åº“æ—¶,è¯·ä½¿ç”¨è·Ÿè¸ªæ–‡ä»¶,è¿™æ ·å½“ä½ å¤åˆ¶ç²˜è´´ç¼–è¾‘åçš„ä»£ç æ—¶,æ‰€æœ‰çš„æ›´æ”¹éƒ½ä¼šçªå‡ºæ˜¾ç¤º.(VSCodeä¼šåœ¨Pythonæ–‡ä»¶çš„è¡Œå·æ—è¾¹ç”¨è“è‰²å°æ¡çªå‡ºæ˜¾ç¤ºæ›´æ”¹).

è¿™æ˜¯ä¸€äº›ä½ å¯ä»¥ç©ç©çœ‹çš„å†…å®¹:
- è®©GPTç»™ä½ å†™å‡½æ•°çš„æµ‹è¯•ä»£ç .ä½ å¯ä»¥ç»™å‡ºæ›´å…·ä½“çš„è¯´æ˜(ä¾‹å¦‚è¦æ±‚ä»–ä½¿ç”¨/ä¸ä½¿ç”¨`unittests`åº“,æˆ–è€…æ‰“å°æ›´å¤šæœ‰ä¿¡æ¯çš„æŠ¥é”™æç¤º).
- é—®GPTå¦‚ä½•é‡æ„ä¸Šé¢çš„å‡½æ•°.(å½“æˆ‘è¿™ä¹ˆåšçš„æ—¶å€™,å®ƒå»ºè®®æˆ‘å°†å‡½æ•°æ‹†åˆ†ä¸ºå­å‡½æ•°,è¿™äº›å­å‡½æ•°æ‰§è¡Œ"è®¡ç®—äº¤ç‚¹"çš„å°ä»»åŠ¡.)

## äºŒç»´å°„çº¿(2D rays)
ç°åœ¨æˆ‘ä»¬å°†ä½¿ç”¨zç»´åº¦å¹¶å‡å®šå°„çº¿ä»åŸç‚¹å‡ºå‘åŒæ—¶å°„åˆ°yç»´åº¦å’Œzç»´åº¦ä¸­.
::: tip TIPS
Difficulty: ğŸ”´ğŸ”´ğŸ”´âšªâšª

Importance: ğŸ”µğŸ”µâšªâšªâšª

ä½ åº”è¯¥èŠ±æœ€å¤š10-15åˆ†é’Ÿåœ¨è¿™ä¸ªç»ƒä¹ ä¸Š.
:::

ä»¿ç…§`make_rays_1d`å®Œæˆ`make_rays_2d`.ç»“æœå¯è§†åŒ–ååº”è¯¥çœ‹èµ·æ¥åƒä¸€ä¸ªé‡‘å­—å¡”,åŸç‚¹åœ¨é¡¶ç‚¹çš„ä½ç½®.
```python
def make_rays_2d(num_pixels_y: int, num_pixels_z: int, y_limit: float, z_limit: float) -> Float[t.Tensor, "nrays 2 3"]:
    '''
    num_pixels_y: The number of pixels in the y dimension
    num_pixels_z: The number of pixels in the z dimension

    y_limit: At x=1, the rays should extend from -y_limit to +y_limit, inclusive of both.
    z_limit: At x=1, the rays should extend from -z_limit to +z_limit, inclusive of both.

    Returns: shape (num_rays=num_pixels_y * num_pixels_z, num_points=2, num_dims=3).
    '''
    pass


rays_2d = make_rays_2d(10, 10, 0.3, 0.3)
render_lines_with_plotly(rays_2d)
```
::: details æ•‘ä¸€æ•‘!æˆ‘ä¸çŸ¥é“æ€ä¹ˆå®Œæˆè¿™ä¸ªå‡½æ•°.
ä¸è¦ç«‹åˆ»æŠŠå®ƒå†™æˆå‡½æ•°,æœ€æœ‰æ•ˆçš„åšæ³•æ˜¯æŠŠä»£ç ä¸€è¡Œè¡Œç”¨REPL(Read-eval-print loop,ç›´æ¥åœ¨ç»ˆç«¯è¾“å…¥`python`çœ‹åˆ°çš„ç•Œé¢)æµ‹è¯•,ä»¥éªŒè¯å®ƒæ˜¯å¦ç¬¦åˆä½ çš„é¢„æœŸ,ç„¶åå†ç»§ç»­.

ä½ å¯ä»¥ç”¨`torch.stack`æ„å»ºè¾“å‡ºå¼ é‡,ä¹Ÿå¯ä»¥ç›´æ¥å°†è¾“å‡ºå¼ é‡åˆå§‹åŒ–ä¸ºæœ€ç»ˆå¤§å°,ç„¶åèµ‹å€¼ç»™`rays[:, 1, 1] = ...`è¿™æ ·çš„åˆ‡ç‰‡.ä¸¤ç§éƒ½æ˜¯å¾ˆå¥½çš„å®ç°æ–¹æ³•.

æ¯ä¸ªyåæ ‡éœ€è¦ä¸€æ¡å°„çº¿å’Œå®ƒå¯¹åº”çš„zåæ ‡-æ¢å¥è¯è¯´,è¿™æ˜¯ä¸€ä¸ªå¤–ç§¯.æœ€ä¼˜é›…çš„æ–¹æ³•æ˜¯è°ƒç”¨ä¸¤æ¬¡`einops.repeat`.ä½ è¿˜å¯ä»¥é€šè¿‡ç»„åˆè°ƒç”¨`unsqueeze`,`expand`å’Œ`reshape`æ¥å®ç°è¿™ä¸ªæ“ä½œ.
:::

::: details SOLUTION
```python 
def make_rays_2d(num_pixels_y: int, num_pixels_z: int, y_limit: float, z_limit: float) -> Float[t.Tensor, "nrays 2 3"]:
    '''
    num_pixels_y: The number of pixels in the y dimension
    num_pixels_z: The number of pixels in the z dimension

    y_limit: At x=1, the rays should extend from -y_limit to +y_limit, inclusive of both.
    z_limit: At x=1, the rays should extend from -z_limit to +z_limit, inclusive of both.

    Returns: shape (num_rays=num_pixels_y * num_pixels_z, num_points=2, num_dims=3).
    '''
    # SOLUTION
    n_pixels = num_pixels_y * num_pixels_z
    ygrid = t.linspace(-y_limit, y_limit, num_pixels_y)
    zgrid = t.linspace(-z_limit, z_limit, num_pixels_z)
    rays = t.zeros((n_pixels, 2, 3), dtype=t.float32)
    rays[:, 1, 0] = 1
    rays[:, 1, 1] = einops.repeat(ygrid, "y -> (y z)", z=num_pixels_z)
    rays[:, 1, 2] = einops.repeat(zgrid, "z -> (y z)", y=num_pixels_y)
    return rays
```
:::